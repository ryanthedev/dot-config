#!/usr/bin/env python3
"""
ao - Unified AeroSpace workspace manager with Harpoon-like functionality
"""
import subprocess
import os
import sys
import json
import argparse
from pathlib import Path
from typing import List, Dict, Optional, Any

class AeroSpaceManager:
    def __init__(self):
        self.apoon_dir = Path.home() / ".apoon"
        self.apoon_dir.mkdir(exist_ok=True)
        self.debug_mode = os.environ.get('AO_DEBUG', '').lower() in ('1', 'true', 'yes')
    
    def debug(self, msg: str):
        if self.debug_mode:
            print(f"[DEBUG] {msg}", file=sys.stderr)
    
    def run(self, cmd: List[str]) -> Optional[str]:
        """Run a command and return output or None on error"""
        self.debug(f"Running: {' '.join(cmd)}")
        try:
            result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)
            return result.stdout.strip()
        except subprocess.CalledProcessError as e:
            self.debug(f"Error: {e.stderr.strip()}")
            return None
    
    def get_focused_monitor(self) -> Dict[str, Any]:
        """Get the focused monitor info"""
        out = self.run(["aerospace", "list-monitors", "--focused", "--json"])
        if not out:
            sys.exit("Could not get focused monitor.")
        try:
            monitors = json.loads(out)
            if not monitors:
                sys.exit("No focused monitor found.")
            return monitors[0]
        except (json.JSONDecodeError, IndexError, KeyError) as e:
            sys.exit(f"Error parsing monitor: {e}")
    
    def get_focused_workspace(self) -> Optional[str]:
        """Get the currently focused workspace name"""
        out = self.run(["aerospace", "list-workspaces", "--focused", "--json"])
        if not out:
            return None
        try:
            return json.loads(out)[0]["workspace"]
        except Exception as e:
            self.debug(f"Error parsing focused workspace: {e}")
            return None
    
    def get_monitor_workspaces(self, monitor_id: int) -> List[str]:
        """Get all workspaces for a monitor"""
        out = self.run(["aerospace", "list-workspaces", "--monitor", str(monitor_id), "--json"])
        if not out:
            return []
        try:
            return [ws["workspace"] for ws in json.loads(out)]
        except Exception as e:
            self.debug(f"Error parsing workspaces: {e}")
            return []
    
    def get_workspace_windows(self, workspace: str) -> List[Dict[str, Any]]:
        """Get windows in a workspace"""
        out = self.run(["aerospace", "list-windows", "--workspace", workspace, "--json"])
        if not out:
            return []
        try:
            return json.loads(out)
        except Exception as e:
            self.debug(f"Error parsing windows: {e}")
            return []
    
    def move_workspace_to_monitor(self, workspace: str, monitor_id: int) -> bool:
        """Safely move a workspace to a specific monitor"""
        self.debug(f"Attempting to move workspace {workspace} to monitor {monitor_id}")
        
        # Try with monitor ID first (most reliable)
        result = self.run(["aerospace", "move-workspace-to-monitor", "--workspace", workspace, str(monitor_id)])
        if result is not None:
            self.debug(f"Successfully moved workspace {workspace} to monitor {monitor_id}")
            return True
        
        # If that fails, get monitor info and try with name
        out = self.run(["aerospace", "list-monitors", "--json"])
        if out:
            try:
                monitors = json.loads(out)
                for m in monitors:
                    if m.get("monitor-id") == monitor_id:
                        monitor_name = m.get("monitor-name", "")
                        if monitor_name:
                            self.debug(f"Retrying with monitor name: {monitor_name}")
                            # Try with quoted name for names with spaces
                            result = self.run(["aerospace", "move-workspace-to-monitor", "--workspace", workspace, f'"{monitor_name}"'])
                            if result is not None:
                                self.debug(f"Successfully moved workspace using monitor name")
                                return True
            except Exception as e:
                self.debug(f"Error getting monitor info: {e}")
        
        self.debug(f"Failed to move workspace {workspace} to monitor {monitor_id}")
        return False
    
    def get_session_file(self, monitor_id: int) -> Path:
        """Get the session file path for a monitor"""
        return self.apoon_dir / f"{monitor_id}_apoon_session"
    
    def clean_session_file(self, session_file: Path, valid_workspaces: List[str]):
        """Clean up session file to only contain valid workspaces"""
        if not session_file.exists():
            return
        
        valid_set = set(valid_workspaces)
        with session_file.open() as f:
            lines = [line.strip() for line in f if line.strip()]
        
        cleaned = [ws for ws in lines if ws in valid_set]
        with session_file.open("w") as f:
            for ws in cleaned:
                f.write(ws + "\n")
        self.debug(f"Cleaned up session file: {session_file}")
    
    def cmd_windows(self, args):
        """Fuzzy select and focus any window across all workspaces (default behavior)"""
        # Get all monitors
        out = self.run(["aerospace", "list-monitors", "--json"])
        if not out:
            print("Could not get monitors.")
            return

        try:
            all_monitors = json.loads(out)
        except json.JSONDecodeError:
            print("Error parsing monitors.")
            return

        # Build list of all windows across all workspaces
        all_windows = []
        for mon in all_monitors:
            mon_id = mon["monitor-id"]
            mon_name = mon.get("monitor-name", f"Monitor {mon_id}")
            workspaces = self.get_monitor_workspaces(mon_id)

            for ws_name in workspaces:
                windows = self.get_workspace_windows(ws_name)

                for win in windows:
                    app_name = win.get("app-name", "Unknown")
                    window_title = win.get("window-title", "")
                    window_id = win.get("window-id", "")

                    # Format: window_id|workspace|monitor_id|display_string
                    display = f"[{app_name}] {window_title} - {ws_name} ({mon_name})"
                    entry = f"{window_id}|{ws_name}|{mon_id}|{display}"
                    all_windows.append(entry)

        if not all_windows:
            print("No windows found.")
            return

        # Use fzf to select
        fzf_entries = [entry.split("|")[3] for entry in all_windows]
        try:
            fzf_process = subprocess.Popen(
                ["fzf", "--prompt=Select window> ", "--preview-window=up:10:wrap"],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                text=True
            )
            selected, _ = fzf_process.communicate("\n".join(fzf_entries))
            selected = selected.strip()
        except FileNotFoundError:
            print("Error: fzf not found. Please install fzf.")
            sys.exit(1)

        if not selected:
            print("No window selected.")
            return

        # Find the matching window entry
        selected_entry = None
        for entry in all_windows:
            if entry.split("|")[3] == selected:
                selected_entry = entry
                break

        if not selected_entry:
            print("Error finding selected window.")
            return

        parts = selected_entry.split("|")
        window_id = parts[0]
        workspace = parts[1]
        monitor_id = int(parts[2])

        # Check if in Kitty Quick Access Terminal
        if os.environ.get("KITTY_WINDOW_ID") and os.environ.get("KITTY_LISTEN_ON"):
            try:
                # Try to close quick access terminal
                subprocess.run(["kitten", "quick-access-terminal"], check=False)
            except:
                pass

        # First switch to the workspace (which will handle monitor switching)
        self.run(["aerospace", "workspace", workspace])

        # Then focus the specific window
        self.run(["aerospace", "focus", "--window-id", window_id])

        # Try to move mouse to window center using cliclick if available
        try:
            # Get window bounds to calculate center
            out = self.run(["aerospace", "list-windows", "--window-id", window_id, "--json"])
            if out:
                windows = json.loads(out)
                if windows and len(windows) > 0:
                    frame = windows[0].get("frame")
                    if frame:
                        x = frame.get("x", 0) + frame.get("width", 0) // 2
                        y = frame.get("y", 0) + frame.get("height", 0) // 2
                        # Try to use cliclick to move mouse
                        subprocess.run(["cliclick", f"m:{x},{y}"], check=False, capture_output=True)
        except:
            # If cliclick is not available or fails, that's okay
            pass

    def cmd_switch(self, args):
        """Fuzzy switch to any workspace on current monitor"""
        monitor = self.get_focused_monitor()
        monitor_id = monitor["monitor-id"]
        workspaces = self.get_monitor_workspaces(monitor_id)

        if not workspaces:
            print("No workspaces found.")
            return

        # Build fzf entries with window titles
        fzf_entries = []
        for ws_name in workspaces:
            windows = self.get_workspace_windows(ws_name)

            # Find preferred window title
            preferred_title = None
            for priority_app in ["Code", "kitty", "Google Chrome"]:
                for win in windows:
                    if win.get("app-name") == priority_app:
                        preferred_title = f"[{priority_app}] {win.get('window-title', '')}"
                        break
                if preferred_title:
                    break

            if not preferred_title and windows:
                win = windows[0]
                preferred_title = f"[{win.get('app-name', '')}] {win.get('window-title', '')}"

            if not preferred_title:
                preferred_title = "(empty)"

            entry = f"{ws_name}: {preferred_title}"
            fzf_entries.append(entry)

        # Use fzf to select
        try:
            fzf_process = subprocess.Popen(
                ["fzf", "--prompt=> ", "--preview-window=up:10:wrap"],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                text=True
            )
            selected, _ = fzf_process.communicate("\n".join(fzf_entries))
            selected = selected.strip()
        except FileNotFoundError:
            print("Error: fzf not found. Please install fzf.")
            sys.exit(1)

        if not selected:
            print("No workspace selected.")
            return

        # Extract workspace name
        ws_name = selected.split(":")[0]

        # Check if in Kitty Quick Access Terminal
        if os.environ.get("KITTY_WINDOW_ID") and os.environ.get("KITTY_LISTEN_ON"):
            try:
                # Try to close quick access terminal
                subprocess.run(["kitten", "quick-access-terminal"], check=False)
            except:
                pass

        # Switch to the workspace
        self.run(["aerospace", "workspace", ws_name])
    
    def cmd_new(self, args):
        """Move focused window to a new indexed workspace (e.g., main -> main-1)"""
        current_ws = self.get_focused_workspace()
        if not current_ws:
            print("No focused workspace found.")
            return
        
        # Parse prefix and index
        if "-" in current_ws:
            prefix, index_str = current_ws.rsplit("-", 1)
            try:
                index = int(index_str)
            except ValueError:
                prefix = current_ws
                index = 0
        else:
            prefix = current_ws
            index = 0
        
        # Create new workspace name
        new_index = index + 1
        new_ws = f"{prefix}-{new_index}"
        
        # Get monitor info
        monitor = self.get_focused_monitor()
        monitor_id = monitor["monitor-id"]
        monitor_name = monitor["monitor-name"]
        
        self.debug(f"Moving window from {current_ws} to {new_ws} on monitor {monitor_id} ({monitor_name})")
        
        # Move window to new workspace
        result = self.run(["aerospace", "move-node-to-workspace", new_ws])
        if result is None:
            print(f"Failed to move window to workspace {new_ws}")
            return
        
        # Assign workspace to monitor
        if not self.move_workspace_to_monitor(new_ws, monitor_id):
            print(f"Warning: Could not assign workspace {new_ws} to monitor {monitor_id}")
        
        # Verify the workspace is on the correct monitor
        monitor_workspaces = self.get_monitor_workspaces(monitor_id)
        if new_ws in monitor_workspaces:
            self.debug(f"Successfully created workspace {new_ws} on monitor {monitor_id}")
        else:
            print(f"Error: Workspace {new_ws} was not created on the expected monitor")
    
    def cmd_next(self, args):
        """Navigate to next workspace with same prefix"""
        current_ws = self.get_focused_workspace()
        if not current_ws:
            print("No focused workspace found.")
            return
        
        monitor = self.get_focused_monitor()
        workspaces = self.get_monitor_workspaces(monitor["monitor-id"])
        
        # Find next workspace
        try:
            current_idx = workspaces.index(current_ws)
            next_idx = (current_idx + 1) % len(workspaces)
            next_ws = workspaces[next_idx]
            self.run(["aerospace", "workspace", next_ws])
        except ValueError:
            print(f"Current workspace {current_ws} not found in monitor workspaces.")
    
    def cmd_prev(self, args):
        """Navigate to previous workspace with same prefix"""
        current_ws = self.get_focused_workspace()
        if not current_ws:
            print("No focused workspace found.")
            return
        
        monitor = self.get_focused_monitor()
        workspaces = self.get_monitor_workspaces(monitor["monitor-id"])
        
        # Find previous workspace
        try:
            current_idx = workspaces.index(current_ws)
            prev_idx = (current_idx - 1) % len(workspaces)
            prev_ws = workspaces[prev_idx]
            self.run(["aerospace", "workspace", prev_ws])
        except ValueError:
            print(f"Current workspace {current_ws} not found in monitor workspaces.")
    
    def cmd_add(self, args):
        """Add current workspace to Harpoon-like session"""
        monitor = self.get_focused_monitor()
        monitor_id = monitor["monitor-id"]
        workspaces = self.get_monitor_workspaces(monitor_id)
        
        session_file = self.get_session_file(monitor_id)
        
        # Clean up session file
        self.clean_session_file(session_file, workspaces)
        
        focused_ws = self.get_focused_workspace()
        if not focused_ws:
            print("No focused workspace found.")
            return
        
        # Read existing session
        if session_file.exists():
            with session_file.open() as f:
                session_lines = [line.strip() for line in f if line.strip()]
        else:
            session_lines = []
        
        # Add if not present
        if focused_ws not in session_lines:
            with session_file.open("a") as f:
                f.write(focused_ws + "\n")
            print(f"Added workspace '{focused_ws}' to session")
        else:
            print(f"Workspace '{focused_ws}' already in session")
    
    def cmd_jump(self, args):
        """Jump to workspace by number (1-9) in session"""
        if not args.number:
            print("Usage: ao jump <number>")
            return
        
        try:
            number = int(args.number)
        except ValueError:
            print("Number must be an integer.")
            return
        
        monitor = self.get_focused_monitor()
        monitor_id = monitor["monitor-id"]
        session_file = self.get_session_file(monitor_id)
        
        if not session_file.exists():
            print("No session file found. Use 'ao add' to add workspaces.")
            return
        
        with session_file.open() as f:
            workspaces = [line.strip() for line in f if line.strip()]
        
        if number < 1 or number > len(workspaces):
            print(f"No workspace at position {number}. Session has {len(workspaces)} workspaces.")
            return
        
        ws_name = workspaces[number - 1]
        
        # Move workspace to monitor and focus
        if not self.move_workspace_to_monitor(ws_name, monitor_id):
            print(f"Warning: Could not move workspace {ws_name} to monitor {monitor_id}")
        
        self.run(["aerospace", "workspace", ws_name])
        print(f"Jumped to workspace '{ws_name}'")
    
    def cmd_list(self, args):
        """List workspaces in current session"""
        monitor = self.get_focused_monitor()
        monitor_id = monitor["monitor-id"]
        session_file = self.get_session_file(monitor_id)
        
        if not session_file.exists():
            print("No session file found. Use 'ao add' to add workspaces.")
            return
        
        with session_file.open() as f:
            workspaces = [line.strip() for line in f if line.strip()]
        
        if not workspaces:
            print("Session is empty. Use 'ao add' to add workspaces.")
            return
        
        current_ws = self.get_focused_workspace()
        
        print(f"Session for monitor {monitor_id}:")
        for i, ws in enumerate(workspaces, 1):
            marker = " *" if ws == current_ws else ""
            print(f"  {i}. {ws}{marker}")
    
    def cmd_edit(self, args):
        """Edit workspace layout across all monitors"""
        import tempfile
        import re

        # Get all monitors
        out = self.run(["aerospace", "list-monitors", "--json"])
        if not out:
            print("Could not get monitors.")
            return

        try:
            all_monitors = json.loads(out)
        except json.JSONDecodeError:
            print("Error parsing monitors.")
            return

        # Build current state
        current_state = {}
        file_content = []
        file_content.append("# AeroSpace Layout Editor")
        file_content.append("# - You can remove windows (they will be closed)")
        file_content.append("# - You can add new workspace names")
        file_content.append("# - You can move workspaces between monitors")
        file_content.append("# - You CANNOT add/remove monitors or add windows")
        file_content.append("# - Lines starting with # are ignored")
        file_content.append("")

        for mon in all_monitors:
            mon_id = mon["monitor-id"]
            mon_name = mon.get("monitor-name", f"Monitor {mon_id}")

            # Store monitor info
            current_state[mon_id] = {
                "name": mon_name,
                "workspaces": {},
                "original_workspaces": []
            }

            # Add monitor header
            file_content.append(f"Monitor {mon_id}: {mon_name}")

            # Get workspaces for this monitor
            workspaces = self.get_monitor_workspaces(mon_id)
            current_state[mon_id]["original_workspaces"] = workspaces.copy()

            if not workspaces:
                file_content.append("  (no workspaces)")

            for ws_name in workspaces:
                file_content.append(f"  {ws_name}:")

                # Get windows for this workspace
                windows = self.get_workspace_windows(ws_name)
                current_state[mon_id]["workspaces"][ws_name] = []

                if not windows:
                    file_content.append("    (empty)")
                else:
                    for win in windows:
                        app_name = win.get("app-name", "Unknown")
                        window_title = win.get("window-title", "")
                        window_id = win.get("window-id", "")

                        # Store window info
                        current_state[mon_id]["workspaces"][ws_name].append(window_id)

                        # Add window line
                        file_content.append(f"    - [{app_name}] {window_title} (id: {window_id})")

            file_content.append("")

        # Write to temp file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            temp_path = f.name
            f.write("\n".join(file_content))

        # Open in editor
        editor = os.environ.get("EDITOR", "vim")
        subprocess.run([editor, temp_path])

        # Read back the edited file
        try:
            with open(temp_path, 'r') as f:
                edited_lines = f.readlines()
        finally:
            os.unlink(temp_path)

        # Parse edited file
        new_state = {}
        current_monitor = None
        current_workspace = None

        monitor_pattern = re.compile(r'^Monitor (\d+):')
        workspace_pattern = re.compile(r'^  ([^\s#].*):$')
        window_pattern = re.compile(r'^    - .*\(id: (\d+)\)$')
        empty_workspace_pattern = re.compile(r'^    \(empty\)$')

        for line in edited_lines:
            line = line.rstrip('\n')

            # Skip comments and empty lines
            if line.startswith('#') or not line.strip():
                continue

            # Check for monitor
            mon_match = monitor_pattern.match(line)
            if mon_match:
                current_monitor = int(mon_match.group(1))
                if current_monitor not in new_state:
                    new_state[current_monitor] = {"workspaces": {}}
                current_workspace = None
                continue

            # Check for workspace
            ws_match = workspace_pattern.match(line)
            if ws_match and current_monitor is not None:
                current_workspace = ws_match.group(1).strip()
                new_state[current_monitor]["workspaces"][current_workspace] = []
                continue

            # Check for window
            win_match = window_pattern.match(line)
            if win_match and current_workspace is not None:
                window_id = int(win_match.group(1))
                new_state[current_monitor]["workspaces"][current_workspace].append(window_id)
                continue

            # Check for empty workspace marker
            if empty_workspace_pattern.match(line) and current_workspace is not None:
                # Workspace remains empty
                continue

        # Apply changes
        changes_made = []

        # Collect all windows in new state (across all workspaces)
        all_new_windows = set()
        for new_mon_id, new_mon_data in new_state.items():
            for ws_name, windows in new_mon_data["workspaces"].items():
                all_new_windows.update(windows)

        # 1. Move windows to different workspaces
        for mon_id, mon_data in current_state.items():
            for ws_name, original_windows in mon_data["workspaces"].items():
                new_windows = []
                # Find where this workspace ended up
                for new_mon_id, new_mon_data in new_state.items():
                    if ws_name in new_mon_data["workspaces"]:
                        new_windows = new_mon_data["workspaces"][ws_name]
                        break

                # Find windows that were moved out of this workspace
                for win_id in original_windows:
                    if win_id not in new_windows:
                        # Check if window was moved to a different workspace
                        new_workspace = None
                        new_monitor = None
                        for new_mon_id, new_mon_data in new_state.items():
                            for new_ws_name, new_ws_windows in new_mon_data["workspaces"].items():
                                if win_id in new_ws_windows and new_ws_name != ws_name:
                                    new_workspace = new_ws_name
                                    new_monitor = new_mon_id
                                    break
                            if new_workspace:
                                break

                        if new_workspace:
                            # Move window to new workspace
                            self.debug(f"Moving window {win_id} from {ws_name} to {new_workspace}")
                            # Focus the window first
                            self.run(["aerospace", "focus", "--window-id", str(win_id)])
                            # Move it
                            result = self.run(["aerospace", "move-node-to-workspace", new_workspace])
                            if result is not None:
                                changes_made.append(f"Moved window {win_id} from '{ws_name}' to '{new_workspace}'")
                        elif win_id not in all_new_windows:
                            # Window was removed entirely - close it
                            self.debug(f"Closing window {win_id}")
                            result = self.run(["aerospace", "close", "--window-id", str(win_id)])
                            if result is not None:
                                changes_made.append(f"Closed window {win_id}")

        # 2. Move workspaces to different monitors
        for mon_id, mon_data in new_state.items():
            for ws_name in mon_data["workspaces"].keys():
                # Find original monitor for this workspace
                original_monitor = None
                for orig_mon_id, orig_data in current_state.items():
                    if ws_name in orig_data["workspaces"]:
                        original_monitor = orig_mon_id
                        break

                # If workspace moved to a different monitor or is new
                if original_monitor != mon_id:
                    if original_monitor is None:
                        # New workspace - create it
                        self.debug(f"Creating new workspace {ws_name} on monitor {mon_id}")
                        # Create by moving to it (it will be created if it doesn't exist)
                        self.run(["aerospace", "workspace", ws_name])
                        # Then ensure it's on the right monitor
                        if self.move_workspace_to_monitor(ws_name, mon_id):
                            changes_made.append(f"Created workspace '{ws_name}' on monitor {mon_id}")
                    else:
                        # Existing workspace - move it
                        self.debug(f"Moving workspace {ws_name} from monitor {original_monitor} to {mon_id}")
                        if self.move_workspace_to_monitor(ws_name, mon_id):
                            changes_made.append(f"Moved workspace '{ws_name}' from monitor {original_monitor} to {mon_id}")

        # Report changes
        if changes_made:
            print("Changes applied:")
            for change in changes_made:
                print(f"  - {change}")
        else:
            print("No changes detected.")
    
    def cmd_cycle(self, args):
        """Cycle through workspaces in session"""
        monitor = self.get_focused_monitor()
        monitor_id = monitor["monitor-id"]
        session_file = self.get_session_file(monitor_id)
        
        if not session_file.exists():
            print("No session file found. Use 'ao add' to add workspaces.")
            return
        
        with session_file.open() as f:
            workspaces = [line.strip() for line in f if line.strip()]
        
        if not workspaces:
            print("Session is empty. Use 'ao add' to add workspaces.")
            return
        
        current_ws = self.get_focused_workspace()
        
        # Check if we're going backwards
        reverse = getattr(args, 'direction', None) == 'prev'
        
        # Find next/prev workspace in session
        try:
            current_idx = workspaces.index(current_ws)
            if reverse:
                next_idx = (current_idx - 1) % len(workspaces)
            else:
                next_idx = (current_idx + 1) % len(workspaces)
        except ValueError:
            # Current workspace not in session, go to first/last
            next_idx = len(workspaces) - 1 if reverse else 0
        
        next_ws = workspaces[next_idx]
        
        # Move workspace to monitor and focus
        if not self.move_workspace_to_monitor(next_ws, monitor_id):
            print(f"Warning: Could not move workspace {next_ws} to monitor {monitor_id}")
        
        self.run(["aerospace", "workspace", next_ws])
        print(f"Cycled to workspace '{next_ws}'")
    
    def cmd_clear(self, args):
        """Clear the session for current monitor"""
        monitor = self.get_focused_monitor()
        monitor_id = monitor["monitor-id"]
        session_file = self.get_session_file(monitor_id)
        
        if session_file.exists():
            session_file.unlink()
            print(f"Cleared session for monitor {monitor_id}")
        else:
            print("No session to clear.")
    
    def cmd_move_next(self, args):
        """Move focused window to next workspace"""
        current_ws = self.get_focused_workspace()
        if not current_ws:
            print("No focused workspace found.")
            return
        
        monitor = self.get_focused_monitor()
        monitor_id = monitor["monitor-id"]
        workspaces = self.get_monitor_workspaces(monitor_id)
        
        if len(workspaces) < 2:
            print("Need at least 2 workspaces to move between.")
            return
        
        # Find next workspace
        try:
            current_idx = workspaces.index(current_ws)
            next_idx = (current_idx + 1) % len(workspaces)
            next_ws = workspaces[next_idx]
            
            self.debug(f"Moving window from {current_ws} to {next_ws}")
            result = self.run(["aerospace", "move-node-to-workspace", next_ws])
            if result is None:
                print(f"Failed to move window to workspace {next_ws}")
            else:
                print(f"Moved window to workspace '{next_ws}'")
                # Optionally follow the window
                if getattr(args, 'follow', False):
                    self.run(["aerospace", "workspace", next_ws])
        except ValueError:
            print(f"Current workspace {current_ws} not found in monitor workspaces.")
    
    def cmd_move_prev(self, args):
        """Move focused window to previous workspace"""
        current_ws = self.get_focused_workspace()
        if not current_ws:
            print("No focused workspace found.")
            return
        
        monitor = self.get_focused_monitor()
        monitor_id = monitor["monitor-id"]
        workspaces = self.get_monitor_workspaces(monitor_id)
        
        if len(workspaces) < 2:
            print("Need at least 2 workspaces to move between.")
            return
        
        # Find previous workspace
        try:
            current_idx = workspaces.index(current_ws)
            prev_idx = (current_idx - 1) % len(workspaces)
            prev_ws = workspaces[prev_idx]
            
            self.debug(f"Moving window from {current_ws} to {prev_ws}")
            result = self.run(["aerospace", "move-node-to-workspace", prev_ws])
            if result is None:
                print(f"Failed to move window to workspace {prev_ws}")
            else:
                print(f"Moved window to workspace '{prev_ws}'")
                # Optionally follow the window
                if getattr(args, 'follow', False):
                    self.run(["aerospace", "workspace", prev_ws])
        except ValueError:
            print(f"Current workspace {current_ws} not found in monitor workspaces.")
    
    def cmd_move_any(self, args):
        """Move a window to any workspace on any monitor using fzf"""
        current_ws = self.get_focused_workspace()
        if not current_ws:
            print("No focused workspace found.")
            return

        # Get all monitors
        out = self.run(["aerospace", "list-monitors", "--json"])
        if not out:
            print("Could not get monitors.")
            return

        try:
            all_monitors = json.loads(out)
        except json.JSONDecodeError:
            print("Error parsing monitors.")
            return

        # Get windows in current workspace
        windows = self.get_workspace_windows(current_ws)
        if not windows:
            print("No windows in current workspace.")
            return

        # If there's only one window, use it directly
        if len(windows) == 1:
            selected_window = windows[0]
            print(f"Using only window: [{selected_window.get('app-name', '')}] {selected_window.get('window-title', '')}")
        else:
            # Build fzf entries for window selection
            window_entries = []
            for win in windows:
                app_name = win.get("app-name", "Unknown")
                window_title = win.get("window-title", "")
                window_id = win.get("window-id", "")
                entry = f"{window_id}|[{app_name}] {window_title}"
                window_entries.append(entry)

            # Select window with fzf
            try:
                fzf_process = subprocess.Popen(
                    ["fzf", "--prompt=Select window> ", "--preview-window=hidden"],
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    text=True
                )
                selected, _ = fzf_process.communicate("\n".join(window_entries))
                selected = selected.strip()
            except FileNotFoundError:
                print("Error: fzf not found. Please install fzf.")
                return

            if not selected:
                print("No window selected.")
                return

            # Extract window ID
            window_id = int(selected.split("|")[0])
            selected_window = next((w for w in windows if w.get("window-id") == window_id), None)
            if not selected_window:
                print("Window not found.")
                return

        # Build list of all workspaces across all monitors
        all_workspaces = []
        for mon in all_monitors:
            mon_id = mon["monitor-id"]
            mon_name = mon.get("monitor-name", f"Monitor {mon_id}")
            workspaces = self.get_monitor_workspaces(mon_id)

            for ws_name in workspaces:
                if ws_name == current_ws:
                    continue  # Skip current workspace

                windows = self.get_workspace_windows(ws_name)

                # Find preferred window title for display
                preferred_title = None
                for priority_app in ["Code", "kitty", "Google Chrome"]:
                    for win in windows:
                        if win.get("app-name") == priority_app:
                            preferred_title = f"[{priority_app}] {win.get('window-title', '')}"
                            break
                    if preferred_title:
                        break

                if not preferred_title and windows:
                    win = windows[0]
                    preferred_title = f"[{win.get('app-name', '')}] {win.get('window-title', '')}"

                if not preferred_title:
                    preferred_title = "(empty)"

                # Format: workspace_name|monitor_id|display_string
                entry = f"{ws_name}|{mon_id}|{ws_name} [{mon_name}]: {preferred_title}"
                all_workspaces.append(entry)

        if not all_workspaces:
            print("No other workspaces available.")
            return

        # Use fzf to select target workspace
        fzf_entries = [entry.split("|")[2] for entry in all_workspaces]
        try:
            fzf_process = subprocess.Popen(
                ["fzf", "--prompt=Move to workspace (any monitor)> ", "--preview-window=up:10:wrap"],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                text=True
            )
            selected, _ = fzf_process.communicate("\n".join(fzf_entries))
            selected = selected.strip()
        except FileNotFoundError:
            print("Error: fzf not found. Please install fzf.")
            return

        if not selected:
            print("No workspace selected.")
            return

        # Find the matching workspace entry
        selected_entry = None
        for entry in all_workspaces:
            if entry.split("|")[2] == selected:
                selected_entry = entry
                break

        if not selected_entry:
            print("Error finding selected workspace.")
            return

        parts = selected_entry.split("|")
        target_ws = parts[0]
        target_monitor_id = int(parts[1])

        # Focus the window first (in case multiple windows and we selected one)
        window_id = selected_window.get("window-id")
        if window_id:
            self.run(["aerospace", "focus", "--window-id", str(window_id)])

        # Move the window to the target workspace
        self.debug(f"Moving window to workspace {target_ws} on monitor {target_monitor_id}")
        result = self.run(["aerospace", "move-node-to-workspace", target_ws])
        if result is None:
            print(f"Failed to move window to workspace {target_ws}")
            return

        # Ensure the workspace is on the correct monitor
        if not self.move_workspace_to_monitor(target_ws, target_monitor_id):
            print(f"Warning: Could not ensure workspace {target_ws} is on monitor {target_monitor_id}")

        print(f"Moved window to workspace '{target_ws}' on monitor {target_monitor_id}")

        # Optionally follow the window
        if getattr(args, 'follow', False):
            self.run(["aerospace", "workspace", target_ws])

    def cmd_move(self, args):
        """Move a window to any workspace using fzf"""
        current_ws = self.get_focused_workspace()
        if not current_ws:
            print("No focused workspace found.")
            return

        monitor = self.get_focused_monitor()
        monitor_id = monitor["monitor-id"]

        # Get windows in current workspace
        windows = self.get_workspace_windows(current_ws)
        if not windows:
            print("No windows in current workspace.")
            return
        
        # If there's only one window, use it directly
        if len(windows) == 1:
            selected_window = windows[0]
            print(f"Using only window: [{selected_window.get('app-name', '')}] {selected_window.get('window-title', '')}")
        else:
            # Build fzf entries for window selection
            window_entries = []
            for win in windows:
                app_name = win.get("app-name", "Unknown")
                window_title = win.get("window-title", "")
                window_id = win.get("window-id", "")
                entry = f"{window_id}|[{app_name}] {window_title}"
                window_entries.append(entry)
            
            # Select window with fzf
            try:
                fzf_process = subprocess.Popen(
                    ["fzf", "--prompt=Select window> ", "--preview-window=hidden"],
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    text=True
                )
                selected, _ = fzf_process.communicate("\n".join(window_entries))
                selected = selected.strip()
            except FileNotFoundError:
                print("Error: fzf not found. Please install fzf.")
                return
            
            if not selected:
                print("No window selected.")
                return
            
            # Extract window ID
            window_id = int(selected.split("|")[0])
            selected_window = next((w for w in windows if w.get("window-id") == window_id), None)
            if not selected_window:
                print("Window not found.")
                return
        
        # Now select target workspace
        workspaces = self.get_monitor_workspaces(monitor_id)
        
        # Build fzf entries for workspace selection
        fzf_entries = []
        for ws_name in workspaces:
            if ws_name == current_ws:
                continue  # Skip current workspace
            
            windows = self.get_workspace_windows(ws_name)
            
            # Find preferred window title for display
            preferred_title = None
            for priority_app in ["Code", "kitty", "Google Chrome"]:
                for win in windows:
                    if win.get("app-name") == priority_app:
                        preferred_title = f"[{priority_app}] {win.get('window-title', '')}"
                        break
                if preferred_title:
                    break
            
            if not preferred_title and windows:
                win = windows[0]
                preferred_title = f"[{win.get('app-name', '')}] {win.get('window-title', '')}"
            
            if not preferred_title:
                preferred_title = "(empty)"
            
            entry = f"{ws_name}: {preferred_title}"
            fzf_entries.append(entry)
        
        if not fzf_entries:
            print("No other workspaces available.")
            return
        
        # Use fzf to select target workspace
        try:
            fzf_process = subprocess.Popen(
                ["fzf", "--prompt=Move to workspace> ", "--preview-window=up:10:wrap"],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                text=True
            )
            selected, _ = fzf_process.communicate("\n".join(fzf_entries))
            selected = selected.strip()
        except FileNotFoundError:
            print("Error: fzf not found. Please install fzf.")
            return
        
        if not selected:
            print("No workspace selected.")
            return
        
        # Extract workspace name
        target_ws = selected.split(":")[0]
        
        # Focus the window first (in case multiple windows and we selected one)
        window_id = selected_window.get("window-id")
        if window_id:
            self.run(["aerospace", "focus", "--window-id", str(window_id)])
        
        # Move the window
        self.debug(f"Moving window to workspace {target_ws}")
        result = self.run(["aerospace", "move-node-to-workspace", target_ws])
        if result is None:
            print(f"Failed to move window to workspace {target_ws}")
        else:
            print(f"Moved window to workspace '{target_ws}'")
            # Optionally follow the window
            if getattr(args, 'follow', False):
                self.run(["aerospace", "workspace", target_ws])

def main():
    manager = AeroSpaceManager()
    
    parser = argparse.ArgumentParser(
        description="ao - Unified AeroSpace workspace manager",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Commands:
  (none)        Fuzzy select any window across all workspaces (default)
  switch        Fuzzy switch to workspace on current monitor
  new           Move focused window to new indexed workspace
  next          Navigate to next workspace
  prev          Navigate to previous workspace
  move          Move window to workspace on current monitor (with fzf)
  move-any      Move window to any workspace on any monitor (with fzf)
  move-next     Move focused window to next workspace
  move-prev     Move focused window to previous workspace
  add           Add current workspace to Harpoon session
  jump N        Jump to workspace N in session (1-9)
  list          List workspaces in session
  edit          Edit workspace layout (manage windows/workspaces across monitors)
  cycle         Cycle through session workspaces
  clear         Clear the session

Examples:
  ao            # Fuzzy window selector (all workspaces)
  ao switch     # Fuzzy workspace switcher (current monitor)
  ao new        # Create new indexed workspace (main -> main-1)
  ao move       # Move window to workspace on current monitor
  ao move-any   # Move window to workspace on any monitor
  ao move-next  # Move window to next workspace
  ao move-prev  # Move window to previous workspace
  ao add        # Add current workspace to session
  ao jump 1     # Jump to first workspace in session
  ao list       # Show session workspaces
  ao cycle      # Cycle through session

Environment:
  AO_DEBUG=1    Enable debug output
  EDITOR        Editor for 'ao edit' (default: vim)
"""
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Commands')

    # Add subcommands
    subparsers.add_parser('switch', help='Fuzzy switch to workspace on current monitor')
    subparsers.add_parser('new', help='Move to new indexed workspace')
    subparsers.add_parser('next', help='Go to next workspace')
    subparsers.add_parser('prev', help='Go to previous workspace')
    
    # Move commands
    move_parser = subparsers.add_parser('move', help='Move window to any workspace on current monitor')
    move_parser.add_argument('--follow', '-f', action='store_true', help='Follow window to new workspace')

    move_any_parser = subparsers.add_parser('move-any', help='Move window to any workspace on any monitor')
    move_any_parser.add_argument('--follow', '-f', action='store_true', help='Follow window to new workspace')

    move_next_parser = subparsers.add_parser('move-next', help='Move window to next workspace')
    move_next_parser.add_argument('--follow', '-f', action='store_true', help='Follow window to new workspace')

    move_prev_parser = subparsers.add_parser('move-prev', help='Move window to previous workspace')
    move_prev_parser.add_argument('--follow', '-f', action='store_true', help='Follow window to new workspace')
    
    subparsers.add_parser('add', help='Add current workspace to session')
    
    jump_parser = subparsers.add_parser('jump', help='Jump to workspace by number')
    jump_parser.add_argument('number', help='Workspace number (1-9)')
    
    subparsers.add_parser('list', help='List session workspaces')
    subparsers.add_parser('edit', help='Edit workspace layout across all monitors')

    cycle_parser = subparsers.add_parser('cycle', help='Cycle through session')
    cycle_parser.add_argument('direction', nargs='?', choices=['next', 'prev'], default='next', help='Direction to cycle (default: next)')
    
    subparsers.add_parser('clear', help='Clear session')
    
    args = parser.parse_args()
    
    # Map commands to methods
    command_map = {
        None: manager.cmd_windows,  # Default - select any window
        'switch': manager.cmd_switch,
        'new': manager.cmd_new,
        'next': manager.cmd_next,
        'prev': manager.cmd_prev,
        'move': manager.cmd_move,
        'move-any': manager.cmd_move_any,
        'move-next': manager.cmd_move_next,
        'move-prev': manager.cmd_move_prev,
        'add': manager.cmd_add,
        'jump': manager.cmd_jump,
        'list': manager.cmd_list,
        'edit': manager.cmd_edit,
        'cycle': manager.cmd_cycle,
        'clear': manager.cmd_clear,
    }

    # Execute command
    command = args.command
    if command in command_map:
        command_map[command](args)
    else:
        # Default to windows if no command
        manager.cmd_windows(args)

if __name__ == "__main__":
    main()